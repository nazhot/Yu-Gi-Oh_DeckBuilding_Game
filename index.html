<!DOCTYPE html>
<html>
  <head>
    <title>Yu-Gi-Oh DeckBuilder</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="/public/css/style.css" />
  </head>
  <body>
    <div id="room-screen">
      <form id="room-form" action="">
        <input id="join-room-input" autocomplete="off" /><button>JOIN GAME</button>
      </form>
      <button id="make-room" onclick="makeRoom()">MAKE GAME</button>
      <p> Rooms: </p>
      <ul id="rooms"></ul>
    </div>
    <div id="loading-screen" style="display:none;">
      <div id="player1-side" class="side1">
        <p style="display: inline-block" id="player1-username"></p>
        <p id="player1-connection" style="display: inline-block">NOT READY</p>
        <button id="start-game-button" style="display: none">START GAME</button>
      </div>
      <div id="player2-side" class="side2">
        <p style="display: inline-block" id="player2-username"></p>
        <p id="player2-connection" style="display: inline-block">NOT READY</p>
      </div>
    </div>
    <div id="playing-screen" style="display: none">
      <div id="player1-play-side" class="side1">
        <div id="player1-card-container" class="card-container">

        </div>
      </div>
      <div id="card-and-powerups">
        <img src="/public/images/back.png" id="middle-card" />
        <div id="abilities-container">

        </div>
      </div>
      <div id="player2-play-side" class="side2">
        <div id="player2-card-container" class="card-container">

        </div>
      </div>
    </div>
    <div id="end-screen" style="display:none;">
      <button id="download-ydk">DOWNLOAD</button>
    </div>
    <script src="/socket.io/socket.io.js"></script>
    <script>
      let socket           = io();
      let roomNameLength   = 4;
      let bothReady        = false;
      let numRerolls       = 5;
      let listNames        = ["card", "ban", "set"]; //names used to get all dropdown information
      let cardTypes        = ["spells", "traps", "monsters"];
      let dropDowns        = {}; //holder for the three drop down elements, since they're so similar in name
      let cardTypeElements = {};
      let myRole           = "";
      let myRoomName       = "";
      let myUsername       = "";

      let imageApiPath = "https://storage.googleapis.com/ygoprodeck.com/pics/"
      let cardWidth    = "12.5%";
  
      let startButton        = document.getElementById("start-game-button");
      let abilitiesContainer = document.getElementById("abilities-container");
      let downloadButton     = document.getElementById("download-ydk");
      let joinRoomForm       = document.getElementById("room-form");

      let myReadyButton;
      let myDrawButton;
      let myRerollButton;

      function makeRoom(){
        const roomHolder = document.getElementById("rooms");
        const elementList   = roomHolder.getElementsByTagName("li");
        let   roomList      = [];
        for (let i = 0; i < elementList.length; i++){
          roomList.push(elementList[i].innerHTML);
        }
        for (let i = 0; i < socket.id.length - roomNameLength; i += roomNameLength){
          const idSlice = socket.id.slice(i, i + roomNameLength);

          if (roomList.includes(idSlice)){
            continue;
          }
          let username = prompt("Please enter your name");
          if (username === null){
            return;
          }
          username = username ? username : "Lame-o";
          myUsername = username;
          document.getElementById("player1-username").innerHTML = myUsername + ":";

          socket.emit("make-room", idSlice, username);
          return;
          
        }
      }

      function makeMyComponents(player){
        //player: String, "player1" or "player2"
        //this is used to generate the buttons/textboxs/dropdowns for each player
        //ended up changing to js-generated HTML components due to the repetitive HTML
        //any change being made to a component required changing it in 2+ places, here it can be one place
        //this strategy won't be best for components that aren't symmetrical, but that's currently no componenets

        if (player === "viewer"){
          return;
        }

        let myReadySide = document.getElementById(player + "-side");

        myReadyButton               = document.createElement("button");
        myReadyButton.id            = player + "-ready-button";
        myReadyButton.className     = "ready-button";
        myReadyButton.style.display = "block";
        myReadyButton.innerHTML     = "NOT READY";
        myReadyButton.addEventListener("click", () => {
          readyButtonClicked(player);
        });
    
        myReadySide.children[1].insertAdjacentElement("afterEnd", myReadyButton);
        
        if (player === "player1"){
          for (let i = 0; i < listNames.length; i++) {
            let listName        = listNames[i]; //card, ban, set
            let capitalListName = listName.charAt(0).toUpperCase() + listName.slice(1);
            let listLabel       = document.createElement("label");
            let list            = document.createElement("select");

            listLabel.htmlFor       = listName + "-list-select";
            listLabel.id            = listName + "-list-label";
            listLabel.style.display = "flex";
            listLabel.innerHTML     = capitalListName + " List";

            list.name          = listName + "-list-select";
            list.id            = listName + "-list-select";
            list.style.display = "flex";

            myReadySide.appendChild(listLabel);
            myReadySide.appendChild(list);
            dropDowns[listName] = list;
          }

          for (const cardType of cardTypes){
            const capitalCardType = cardType.charAt(0).toUpperCase() + cardType.slice(1);
            let cardTypeLabel     = document.createElement("label");
            let cardTypeTextBox   = document.createElement("input");

            cardTypeLabel.htmlFor       = cardType + "-count";
            cardTypeLabel.id            = cardType + "-count-label";
            cardTypeLabel.style.display = "flex";
            cardTypeLabel.innerHTML     = capitalCardType + " Count";

            cardTypeTextBox.id                    = cardType + "-count";
            cardTypeTextBox.name                  = cardType + "-count";
            cardTypeTextBox.style.display         = "flex";
            cardTypeTextBox.type                  = "text"; //super neat fun fact, firefox doesn't care if you type non-numbers into here, just need to check in function
            cardTypeTextBox.style.backgroundColor = "white";
            cardTypeTextBox.onkeyup               = getExpectedDeckSize;
            cardTypeTextBox.onpaste               = getExpectedDeckSize;
            cardTypeElements[cardType]            = cardTypeTextBox;

            myReadySide.appendChild(cardTypeLabel);
            myReadySide.appendChild(cardTypeTextBox);
          }

          let randomValueLabel    = document.createElement("label");
          let randomValueDropdown = document.createElement("select");
          
          randomValueLabel.htmlFor       = "randomFactor";
          randomValueLabel.style.display = "flex";
          randomValueLabel.innerHTML     = "Random Factor";

          randomValueDropdown.style.display = "flex";
          randomValueDropdown.id            = "randomFactor";

          for (let i = 0; i <= 100; i += 25){
            let randomValue = document.createElement("option");
            randomValue.innerHTML = i + "%";
            randomValue.value = i / 100.0;
            randomValueDropdown.appendChild(randomValue);
          }
          
          myReadySide.appendChild(randomValueLabel);
          myReadySide.appendChild(randomValueDropdown);

          socket.emit("getLists", myRoomName);
        }

        let myPlaySide = document.getElementById(player + "-play-side");

        myDrawButton               = document.createElement("button");
        myDrawButton.id            = player + "-draw-card";
        myDrawButton.className     = "draw-card-button";
        myDrawButton.style.display = "none";
        myDrawButton.innerHTML     = "Draw Card";
        myDrawButton.addEventListener("click", () => {
          socket.emit("draw-card", myRoomName, myRole);
          myDrawButton.style.display   = "none";
          myRerollButton.style.display = "none";
        });

        myRerollButton               = document.createElement("button");
        myRerollButton.id            = player + "-reroll-button";
        myRerollButton.className     = "reroll-card-button";
        myRerollButton.style.display = "none";
        setRerollText(numRerolls);
        myRerollButton.addEventListener("click", () => {
          //number of rerolls left is checked here to avoid any issues server side, since it can't readily check, it'd have to be told
          //numRerolls is decremented when socket recieves the reroll message
          socket.emit("reroll", myRoomName, player);
        });

        myPlaySide.appendChild(myDrawButton);
        myPlaySide.appendChild(myRerollButton);

      }

      function makeToolTipText(abilityData){
        let toolText         = abilityData.description + "<br />Me<br />";
        const targetMe       = abilityData.targetMe;
        const targetOpponent = abilityData.targetOpponent;

        for (const trait in targetMe){
          const value = targetMe[trait];
          toolText += "•" +  trait + ": " + value + "<br />";
        }
        toolText += "<br />Opponent";
        for (const trait in targetOpponent){
          const value = targetOpponent[trait];
          toolText += "<br />•" +  trait + ": " + value;
        }
   


        return toolText;

      }

      function makeAbilityComponent(abilityName, abilityData, row, col){
        let newAbility = document.createElement("div");

        newAbility.className             = "ability-tooltip";
        newAbility.id                    = abilityData.id + "-ability"
        newAbility.style.backgroundColor = "orange";
        newAbility.innerHTML             = abilityName;
        newAbility.style.gridRow         = row + " / span 1";
        newAbility.style.gridColumn      = col + " / span 1";
        newAbility.addEventListener("click", () => {
          socket.emit("ability", myRoomName, abilityName, myRole);
        });

        let newAbilityToolTip       = document.createElement("span");
        newAbilityToolTip.id        = abilityData.id + "-ability-tooltip-text"
        newAbilityToolTip.className = "ability-tooltip-text";
        newAbilityToolTip.innerHTML = makeToolTipText(abilityData);

        abilitiesContainer.appendChild(newAbility);
        newAbility.appendChild(newAbilityToolTip);
        
      }

      function makeAbilities(abilitiesData){
        let rowIndex    = 1;
        let colIndex    = 1;
        const totalRows = 2;
        const totalCols = 5;

        for (const abilityName in abilitiesData){
          makeAbilityComponent(abilityName, abilitiesData[abilityName], rowIndex, colIndex);
          colIndex++;
          if (colIndex > totalCols){
            colIndex = 1;
            rowIndex++;
          }
        }
      }

      function checkIfBothReady() {
        let player1 = document.getElementById("player1-connection").innerHTML;
        let player2 = document.getElementById("player2-connection").innerHTML;
        return player1 === "READY" && player2 === "READY";
      }

      function readyButtonClicked(player) {
        //player: "player1" or "player2"
        if (myReadyButton.innerHTML === "READY") {
          myReadyButton.innerHTML             = "NOT READY";
          myReadyButton.style.backgroundColor = "darkred";
        } else {
          myReadyButton.innerHTML             = "READY";
          myReadyButton.style.backgroundColor = "darkgreen";
        }
        //send out message so that other player/viewer can see your current status
        socket.emit("ready-change", myRoomName, player, myReadyButton.innerHTML);
      }

      function setDrawnCard(playerSide, drawCard, samePlayer, cardId) {
        //playerSide: dom element, div that correlates with the users side
        //drawCard:   String,      path to the card image to display
        //samePlayer: boolean,     if the player calling this function is the same one that had drawn the card
        //cardId:     String,      the id of the card, to be stored in the alt of the image, for updating counts on server side if rerolled
        let newCard = document.createElement("img");
        newCard.src = drawCard;
        newCard.alt = cardId;
        newCard.style.width = cardWidth;
        //when moused over, show the image in the middle card
        //when not moused over, default to card back
        newCard.onmouseover = () => {
          let middleCard = document.getElementById("middle-card");
          middleCard.src = newCard.src;
        };
        newCard.onmouseleave = () => {
          let middleCard = document.getElementById("middle-card");
          middleCard.src = "/public/images/back.png";
        };
        playerSide.appendChild(newCard);
      }

      function checkIfNumber(value){
        return (!isNaN(value) && !isNaN(parseFloat(value)));
      }

      function getExpectedDeckSize(){
        let totalCount = 0;
        for (const cardType of cardTypes){
          let textBox = document.getElementById(cardType + "-count");
          let value = textBox.value;
          totalCount += Math.floor(value);
          if (isNaN(totalCount)){
            textBox.style.backgroundColor = "red";
            return -1;
          }
          textBox.style.backgroundColor = "white";
        }
        return totalCount;
      }

      function setRerollText(playerRerolls){
        myRerollButton.innerHTML = "Re-Roll (" + playerRerolls + ")";
      }

      function setAbilityStatus(abilityStatus){
        if (myRole === "viewer"){
          return;
        }
        const abilities = abilityStatus[myRole];
        
        for (const abilityId in abilities){
          const canUse     = abilities[abilityId];
          const abilityDiv = document.getElementById(abilityId + "-ability");

          abilityDiv.style.opacity = canUse ? 1.0 : 0.2;
        }
      }

      function download(filename, text) {
        var element = document.createElement('a');
        element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
        element.setAttribute('download', filename);

        element.style.display = 'none';
        document.body.appendChild(element);

        element.click();

        document.body.removeChild(element);
      }


      startButton.addEventListener("click", () => {
        let data = {};

        for (const listName of listNames){
          data[listName + "-dropdown"] = dropDowns[listName].value;
        }

        for (const cardType of cardTypes){
          let value = cardTypeElements[cardType].value;
          value = value === "" ? 0 : value;
          data[cardType + "-textbox"] = Math.floor(value);
        }

        data.randomFactor = document.getElementById("randomFactor").value;
        socket.emit("start-game", myRoomName, data);
        myDrawButton.style.display   = "flex";
        myRerollButton.style.display = "flex";
      });

      downloadButton.addEventListener("click", () => {
        socket.emit("download", myRoomName, myRole);
      });

      joinRoomForm.addEventListener("submit", (e) => {
        e.preventDefault();
        const roomInput = document.getElementById("join-room-input");
        if (roomInput.value){
          const roomList = document.getElementById("rooms").getElementsByTagName("li");
          for (let i = 0; i < roomList.length; i++){
            const room = roomList[i].innerHTML;
            if (roomInput.value === room){
              let username = prompt("Please enter your name");
              username = username ? username : "Lame-o";
              if (username === null){
                return;
              }
              socket.emit("join-room", room, username);
              return;
            }
          }
          alert("No room found with name " + roomInput.value);
        }
        
 
      });

      socket.on("rooms", (roomList) => {
        const roomsParent = document.getElementById("rooms");
        while (roomsParent.firstChild){
          roomsParent.removeChild(roomsParent.firstChild);
        }
        for (const roomName of roomList){
          const room = document.createElement("li");

          room.innerHTML = roomName;

          roomsParent.appendChild(room);

        }
      });

      socket.on("join-room", (playerRole, room, player1Name, player2Name) => {
        document.getElementById("player1-username").innerHTML = player1Name + ":";
        if (player2Name != ""){
          document.getElementById("player2-username").innerHTML = player2Name + ":";
        }

        if (myRole != ""){ //already joined
          return; 
        }

        myRole = playerRole;
        myRoomName = room;

        document.getElementById("room-screen").style.display    = "none";
        document.getElementById("loading-screen").style.display = "block";

        makeMyComponents(playerRole);
        
      });

      socket.on("room-closed", () => {       
        document.getElementById("room-screen").style.display    = "block";
        document.getElementById("loading-screen").style.display = "none";
        document.getElementById("playing-screen").style.display = "none";
        alert("ROOM CLOSED");
      });

      socket.on("ready-change", (player, readyText) => {
        //player:    String, "player1" or "player2", whoever clicked their ready button
        //readyText: String, "READY" or "NOT READY", whatever the button's text value now is
        let readyTextComponent = document.getElementById(player + "-connection");
        readyTextComponent.innerHTML = readyText;
        //if client is player1, additional check has to be done to see if both players are ready and start button should be shown
        if (myRole === "player1") {
          bothReady = checkIfBothReady();
          if (bothReady && getExpectedDeckSize() >= 40 && getExpectedDeckSize() <= 60) {
            startButton.style.display = "block";
          } else {
            startButton.style.display = "none";
          }
        }
      });

      socket.on("setLists", (cardLists, banLists, setLists) => {
        //all lists are arrays, pertaining to the names of the files for each one
        //used to set the drop down entries
        let lists = {
          card: cardLists,
          ban: banLists,
          set: setLists,
        };
        for (let i = 0; i < listNames.length; i++) {
          let listName = listNames[i]; //card, ban, set
          for (let j = 0; j < lists[listName].length; j++) {
            let list     = lists[listName];
            let newEntry = document.createElement("option");

            newEntry.value     = list[j];
            newEntry.innerHTML = list[j];

            let dropDown = document.getElementById(listName + "-list-select");
            dropDown.appendChild(newEntry);
          }
        }
      });

      socket.on("start-game", (abilitiesData) => {
        //player 1 takes care of making the right buttons visible when they click the start button
        //no need to do so here, just change the screen
        makeAbilities(abilitiesData);
        document.getElementById("loading-screen").style.display = "none";
        document.getElementById("playing-screen").style.display = "inline-block";
        
      });

      socket.on("draw-card", (player, drawCard) => {
        //player1:  boolean, whether the player that drew the card is player 1
        //drawCard: String,  cardID of the card that was randomly selected to be added to the deck
        let playerSide;
        let newCardPath;
        let samePlayer = myRole === player;
        let cardId = drawCard;
        if (myRole === "viewer") {
          //samePlayer is set to true to ensure that viewer card list contains all cards
          newCardPath = imageApiPath + drawCard + ".jpg";
          playerSide  = document.getElementById(player + "-card-container");
          samePlayer  = true;
        } else if (myRole === player) {
          //player that drew a card
          //player sets their own buttons to be hidden, no need to do so here
          newCardPath = imageApiPath + drawCard + ".jpg";
          playerSide  = document.getElementById(player + "-card-container");
        } else {
          //not the player that drew a card
          newCardPath = "/public/images/back.png";
          cardId = "-1";
          playerSide = document.getElementById(player+ "-card-container");
          myDrawButton.style.display   = "flex";
          myRerollButton.style.display = "flex";
        }
        setDrawnCard(playerSide, newCardPath, samePlayer, cardId);
      });

      socket.on("reroll", (newCardId, player) => {
        const playerSide = document.getElementById(player + "-card-container");
        if (myRole === "viewer" || myRole === player) {
          let lastCard = playerSide.lastChild;
          lastCard.src = imageApiPath + newCardId + ".jpg";
          lastCard.alt = newCardId;
        }
      });

      socket.on("data-change", (player1Rerolls, player2Rerolls, abilityStatus) => {
        setRerollText(myRole === "player1" ? player1Rerolls : player2Rerolls);
        setAbilityStatus(abilityStatus);
      });

      // socket.on("ability", (player) => {
      //   if (myRole === "viewer"){
      //     return;
      //   }
      //   if (myRole === player){
      //     setRerollText(myRerolls);
      //   } else {
      //     setRerollText(opponentRerolls);
      //   }
      // });

      socket.on("end-game", () => {
        if (myRole === "viewer"){
          return;
        }
        const playingScreen = document.getElementById("playing-screen");
        const endScreen     = document.getElementById("end-screen");

        playingScreen.style.display = "none";
        endScreen.style.display     = "flex";
      });

      socket.on("download", (player, ydkFile) => {
        if (myRole === "viewer"){
          return;
        }
        if (myRole === player){
          download("NoahDeck.ydk", ydkFile);
        }
      });
    </script>
  </body>
</html>
